#include <WiFi.h>
#include <HTTPClient.h>
#include <HTTPUpdate.h>
#include <WiFiClientSecure.h>
#include "cert.h"
#include <ArduinoJson.h>
#include <UniversalTelegramBot.h>
#ifdef ESP32
#endif

const char * ssid = "";//enter wifi name 
const char * wifiPassword = "";//wifi password
int status = WL_IDLE_STATUS;

#define BOTtoken "673748553:AARiK3fTEz8ctbYGnBBBu8aOSz4GOuikT0N"//enter the generated telegram BOTtoken 
#define CHAT_ID "521490065"enter chatid number from telegram 

#ifdef ESP8266
  X509List cert(TELEGRAM_CERTIFICATE_ROOT);
#endif

WiFiClientSecure client;
UniversalTelegramBot bot(BOTtoken, client);

int botRequestDelay = 1000;
unsigned long lastTimeBotRan;

String FirmwareVer = {
    "2.0"
};

#define URL_fw_Version "http://raw.githubusercontent.com/Abhijithmuralidharan21/ESP32/main/version.txt"
#define URL_fw_Bin "http://raw.githubusercontent.com/Abhijithmuralidharan21/ESP32/main/fw.bin"

void setup() {
    Serial.print("Active Firmware Version:");
    Serial.println(FirmwareVer);
    Serial.begin(115200);
    #ifdef ESP8266
    configTime(0, 0, "pool.ntp.org");      // get UTC time via NTP
    client.setTrustAnchors(&cert); // Add root certificate for api.telegram.org
    #endif

    WiFi.begin(ssid, wifiPassword);
    #ifdef ESP32
    client.setCACert(TELEGRAM_CERTIFICATE_ROOT); // Add root certificate for api.telegram.org
    #endif

    Serial.print("Connecting to WiFi");
    while (WiFi.status() != WL_CONNECTED) {
        delay(500);
        Serial.print(".");

        int i = 0;
        if (i == 10) {
            ESP.restart();
        }
        i++;
    }
    Serial.println("Connected To Wifi");
}
/////
// Handle what happens when you receive new messages
void handleNewMessages(int numNewMessages) {
  Serial.println("handleNewMessages");
  Serial.println(String(numNewMessages));

  for (int i=0; i<numNewMessages; i++) {
    // Chat id of the requester
    String chat_id = String(bot.messages[i].chat_id);
    if (chat_id != CHAT_ID){
      bot.sendMessage(chat_id, "Unauthorized user", "");
      continue;
    }
    
    // Print the received message
    String text = bot.messages[i].text;
    Serial.println(text);

    String from_name = bot.messages[i].from_name;

    if (text == "/start") {
      String welcome = "Welcome to ESP32 OTA update and control , " + from_name + ".\n";
      welcome += "Use the following commands for update.\n";
      welcome += "/update to update the firmware \n";
      
      bot.sendMessage(chat_id, welcome, "");
    }
    
    if (text == "/update") {
      bot.sendMessage(chat_id, "Updatation is under progress","");
      if (FirmwareVersionCheck()) {
         bot.sendMessage(chat_id, "Updating Device Latest Firmware Version is available"); 
         firmwareUpdate();
      }
       else{
         bot.sendMessage(chat_id, "Updating Device no update version is same");
        }                  
    }  
  }
}

void loop() {

    delay(1000);
    Serial.print(" Active Firmware Version:");
    Serial.println(FirmwareVer);
    delay(1000);

    if (WiFi.status() != WL_CONNECTED) {
        reconnect();
    }
    if (millis() > lastTimeBotRan + botRequestDelay)  {
      int numNewMessages = bot.getUpdates(bot.last_message_received + 1);

     while(numNewMessages) {
       Serial.println("got response");
       handleNewMessages(numNewMessages);
       numNewMessages = bot.getUpdates(bot.last_message_received + 1);
      }
    lastTimeBotRan = millis();
  }
}
    


void reconnect() {
    int i = 0;
    // Loop until we're reconnected
    status = WiFi.status();
    if (status != WL_CONNECTED) {
        WiFi.begin(ssid, wifiPassword);
        while (WiFi.status() != WL_CONNECTED) {
            delay(500);
            Serial.print(".");
            if (i == 10) {
                ESP.restart();
            }
            i++;
        }
        Serial.println("Connected to AP");
    }
}

void firmwareUpdate(void) {
    WiFiClientSecure client;
    client.setCACert(rootCACertificate);
    t_httpUpdate_return ret = httpUpdate.update(client, URL_fw_Bin);

    switch (ret) {
    case HTTP_UPDATE_FAILED:
        Serial.printf("HTTP_UPDATE_FAILD Error (%d): %s\n", httpUpdate.getLastError(), httpUpdate.getLastErrorString().c_str());
        break;

    case HTTP_UPDATE_NO_UPDATES:
        Serial.println("HTTP_UPDATE_NO_UPDATES");
        break;

    case HTTP_UPDATE_OK:
        Serial.println("HTTP_UPDATE_OK");
        break;
    }
}


int FirmwareVersionCheck(void) {
    String payload;
    int httpCode;
    String FirmwareURL = "";
    FirmwareURL += URL_fw_Version;
    FirmwareURL += "?";
    FirmwareURL += String(rand());
    Serial.println(FirmwareURL);
    WiFiClientSecure * client = new WiFiClientSecure;

    if (client) {
        client -> setCACert(rootCACertificate);
        HTTPClient http;
        http.begin(URL_fw_Version); //Specify the URL
        httpCode = http.GET(); 
        delay(100);
        Serial.println(HTTP_CODE_OK);
        Serial.println(httpCode);
            
        if (httpCode == HTTP_CODE_OK) // if version received
        {
           payload = http.getString(); // save received version
           Serial.println(payload);

        } 
        else  
        {
          Serial.print("Error Occured During Version Check: ");
          Serial.println(httpCode);
        }
        http.end();
        
        delete client;
    }


    if (httpCode == HTTP_CODE_OK) // if version received
    {
      //int numNewMessages = bot.getUpdates(bot.last_message_received + 1);
      //for (int i=0; i<numNewMessages; i++) {
      //  String chat_id = String(bot.messages[i].chat_id);      
        payload.trim();
        
        Serial.println(payload);        
        if (payload.equals(FirmwareVer)) {
            Serial.printf("\nDevice  IS Already on Latest Firmware Version:%s\n", FirmwareVer);
            //bot.sendMessage(chat_id, "UpdatingDevice  IS Already on Latest Firmware Version:%s\n", FirmwareVer);            
            return 0;
        } else {
            Serial.println(payload);
            Serial.println("New Firmware Detected");
            //bot.sendMessage(chat_id, "New Firmware Detected");
            return 1;
        }
      //}
    }
    return 0;
}
